/*
 *   openMMC -- Open Source modular IPM Controller firmware
 *
 *   Copyright (C) 2021  Wojciech Ruclo <wojciech.ruclo@creotech.pl>
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>
 *
 *   Based on: https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_CLI/FreeRTOS_Plus_CLI_IO_Interfacing_and_Task.html
 */

/* FreeRTOS Includes */
#include "FreeRTOS.h"
#include "FreeRTOS_CLI.h"
#include "pin_mapping.h"
#include "task.h"

/* Project Includes */
#include "cli.h"
#include "cli_commands.h"
#include "port.h"
#include "task_priorities.h"

/*
 * The task that implements the command console processing.
 */
static void CommandConsoleTask(void *pvParameters);

/* Holds the handle of the task that implements the UART command console. */
static xTaskHandle xCommandConsoleTask = NULL;

static void CommandConsoleStart(void)
{
    xTaskCreate(
            CommandConsoleTask, /* The task that implements the command console. */
            "CLI", /* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
            (configMINIMAL_STACK_SIZE * 2), /* The size of the stack allocated to the task. */
            NULL, /* The parameter is not used, so NULL is passed. */
            tskCLI_PRIORITY,/* The priority allocated to the task. */
            &xCommandConsoleTask); /* Used to store the handle to the created task. */
}

typedef enum ControlSequenceState {
    IDLE,
    ESCAPE_SEQUENCE,
    CONTROL_SEQUENCE,
    OTHER_SEQUENCE
} ControlSequenceState_t;

static void CommandConsoleTask(void *pvParameters)
{
    uint8_t cRxedChar, cInputIndex = 0, cLastInputIndex = 0;
    BaseType_t xMoreDataToFollow;

    /* The input and output buffers are declared static to keep them off the stack. */
    static int8_t pcOutputString[MAX_OUTPUT_LENGTH],
        pcInputString[MAX_INPUT_LENGTH], pcLastInputString[MAX_INPUT_LENGTH];
    memset(pcInputString, 0x00, MAX_INPUT_LENGTH);
    memset(pcLastInputString, 0x00, MAX_INPUT_LENGTH);

    ControlSequenceState_t cState = IDLE;

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    static const char * const cWelcomeMessage =
            "\r\nCommand Line Interface.\r\nType <help> to view a list of registered commands.\r\n> ";
    static const char * const cNewLine = "\r\n> ";

    /* Obtain the address of the output buffer.  Note there is no mutual
     exclusion on this buffer as it is assumed only one command console
     interface will be used at any one time. */
    // char *cOutputBuffer = FreeRTOS_CLIGetOutputBuffer();
    vTaskDelay(500 / portTICK_PERIOD_MS);

    /* Send a welcome message to the user. */
    uart_send(UART_DEBUG, cWelcomeMessage, strlen((char *) cWelcomeMessage));

    for (;;) {
        /* Only interested in reading one character at a time. */
        if (uart_read(UART_DEBUG, &cRxedChar, 1)) {
            switch (cState) {
            case ESCAPE_SEQUENCE:
                if (cRxedChar == '[') cState = CONTROL_SEQUENCE;
                else cState = OTHER_SEQUENCE;
                break;
            case CONTROL_SEQUENCE:
                if (cRxedChar == 'A') {
                    cInputIndex = cLastInputIndex;
                    memcpy(pcInputString, pcLastInputString, cLastInputIndex+1);
                    uart_send(UART_DEBUG, "\r", 1);
                    uart_send(UART_DEBUG, pcInputString, cInputIndex);
                }
                cState = IDLE;
                break;
            case OTHER_SEQUENCE:
                cState = IDLE;
                break;
            case IDLE:
                if (cRxedChar == '\r') {
                    /* A newline character was received, so the input command string is
                     complete and can be processed. */
                    uart_send(UART_DEBUG, "\r\n", 2);

                    /* The command interpreter is called repeatedly until it returns pdFALSE.*/
                    do {
                        /* Send the command string to the command interpreter.  Any
                         output generated by the command interpreter will be placed in the
                         pcOutputString buffer. */
                        xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
                                (char *) pcInputString, /* The command string.*/
                                (char *) pcOutputString, /* The output buffer. */
                                MAX_OUTPUT_LENGTH /* The size of the output buffer. */
                                );

                        /* Write the output generated by the command interpreter to the
                         console. */
                        uart_send(UART_DEBUG, pcOutputString, strlen((char *) pcOutputString));

                    } while (xMoreDataToFollow != pdFALSE);

                    /* All the strings generated by the input command have been sent.
                     Processing of the command is complete.  Clear the input string ready
                     to receive the next command. */
                    cLastInputIndex = cInputIndex;
                    memcpy(pcLastInputString, pcInputString, cInputIndex+1);
                    cInputIndex = 0;
                    memset(pcInputString, 0x00, MAX_INPUT_LENGTH);

                    uart_send(UART_DEBUG, cNewLine, strlen(cNewLine));

                } else {
                    if (cRxedChar == '\n') {
                        /* Ignore the character. */
                    } else if (cRxedChar == '\b' || cRxedChar == '\177') {
                        /* Backspace was pressed.  Erase the last character in the input
                         buffer - if there are any. */
                        if (cInputIndex > 0) {
                            uart_send(UART_DEBUG, "\b \b", 3);
                            cInputIndex--;
                            pcInputString[cInputIndex] = '\0';
                        }
                    } else if (cRxedChar == '\e') { 
                        cState = ESCAPE_SEQUENCE;
                    } else {
                        /* A character was entered.  It was not a new line, backspace
                         or carriage return, so it is accepted as part of the input and
                         placed into the input buffer.  When a \n is entered the complete
                         string will be passed to the command interpreter. */
                        if ((cRxedChar >= ' ') && (cRxedChar <= '~')) {
                            if (cInputIndex < MAX_INPUT_LENGTH-1) {
                                /* Echo the character back. */
                                uart_send(UART_DEBUG, &cRxedChar, 1);
                                pcInputString[cInputIndex] = cRxedChar;
                                cInputIndex++;
                            }
                        }
                    }
                }
                break;
            }
        }
    }
}

void cli_init(void)
{
    printf("Command Line Interface enabled!\n");

    CommandConsoleStart();
    RegisterCLICommands();
}
