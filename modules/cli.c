/*
 *   openMMC -- Open Source modular IPM Controller firmware
 *
 *   Copyright (C) 2021  Wojciech Ruclo <wojciech.ruclo@creotech.pl>
 *
 *   This program is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   This program is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with this program.  If not, see <http://www.gnu.org/licenses/>.
 *
 *   @license GPL-3.0+ <http://spdx.org/licenses/GPL-3.0+>
 *
 *   Based on: https://www.freertos.org/FreeRTOS-Plus/FreeRTOS_Plus_CLI/FreeRTOS_Plus_CLI_IO_Interfacing_and_Task.html
 */

/* FreeRTOS Includes */
#include "FreeRTOS.h"
#include "FreeRTOS_CLI.h"
#include "task.h"

/* Project Includes */
#include "cli.h"
#include "cli_commands.h"
#include "port.h"

/*
 * The task that implements the command console processing.
 */
static void CommandConsoleTask(void *pvParameters);

/* Holds the handle of the task that implements the UART command console. */
static xTaskHandle xCommandConsoleTask = NULL;

static void CommandConsoleStart(void)
{
    xTaskCreate(
            CommandConsoleTask, /* The task that implements the command console. */
            "CLI", /* Text name assigned to the task.  This is just to assist debugging.  The kernel does not use this name itself. */
            (configMINIMAL_STACK_SIZE * 2), /* The size of the stack allocated to the task. */
            NULL, /* The parameter is not used, so NULL is passed. */
            (tskIDLE_PRIORITY + 1),/* The priority allocated to the task. */
            &xCommandConsoleTask); /* Used to store the handle to the created task. */
}

static void CommandConsoleTask(void *pvParameters)
{
    uint8_t cRxedChar, cInputIndex = 0;
    BaseType_t xMoreDataToFollow;

    /* The input and output buffers are declared static to keep them off the stack. */
    static int8_t pcOutputString[MAX_OUTPUT_LENGTH], pcInputString[MAX_INPUT_LENGTH];

    vTaskDelay(1000 / portTICK_PERIOD_MS);

    static const char * const cWelcomeMessage =
            "\r\nCommand Line Interface.\r\nType <help> to view a list of registered commands.\r\n> ";
    static const char * const cNewLine = "\r\n> ";

    /* Obtain the address of the output buffer.  Note there is no mutual
     exclusion on this buffer as it is assumed only one command console
     interface will be used at any one time. */
    // char *cOutputBuffer = FreeRTOS_CLIGetOutputBuffer();
    vTaskDelay(500 / portTICK_PERIOD_MS);

    /* Send a welcome message to the user. */
    Chip_UART_SendBlocking(LPC_UART3, cWelcomeMessage, strlen((char *) cWelcomeMessage));

    for (;;) {
        /* Only interested in reading one character at a time. */
        if (Chip_UART_Read(LPC_UART3, &cRxedChar, 1)) {

            /* Echo the character back. */
            Chip_UART_SendByte(LPC_UART3, cRxedChar);

            if (cRxedChar == '\r') {
                /* A newline character was received, so the input command string is
                 complete and can be processed. */

                /* The command interpreter is called repeatedly until it returns pdFALSE.*/
                do {
                    /* Send the command string to the command interpreter.  Any
                     output generated by the command interpreter will be placed in the
                     pcOutputString buffer. */
                    xMoreDataToFollow = FreeRTOS_CLIProcessCommand(
                            (char *) pcInputString, /* The command string.*/
                            (char *) pcOutputString, /* The output buffer. */
                            MAX_OUTPUT_LENGTH /* The size of the output buffer. */
                            );

                    /* Write the output generated by the command interpreter to the
                     console. */
                    Chip_UART_SendBlocking(LPC_UART3, pcOutputString, strlen((char *) pcOutputString));

                } while (xMoreDataToFollow != pdFALSE);

                /* All the strings generated by the input command have been sent.
                 Processing of the command is complete.  Clear the input string ready
                 to receive the next command. */
                cInputIndex = 0;
                memset(pcInputString, 0x00, MAX_INPUT_LENGTH);

                Chip_UART_SendBlocking(LPC_UART3, cNewLine, strlen(cNewLine));

            } else {
                if (cRxedChar == '\n') {
                    /* Ignore the character. */
                }
                else if (cRxedChar == '\b' || cRxedChar == '\177') {
                    /* Backspace was pressed.  Erase the last character in the input
                     buffer - if there are any. */
                    if (cInputIndex > 0) {
                        cInputIndex--;
                        pcInputString[cInputIndex] = '\0';
                    }
                }
                else {
                    /* A character was entered.  It was not a new line, backspace
                     or carriage return, so it is accepted as part of the input and
                     placed into the input buffer.  When a \n is entered the complete
                     string will be passed to the command interpreter. */
                    if ((cRxedChar >= ' ') && (cRxedChar <= '~')) {
                        if (cInputIndex < MAX_INPUT_LENGTH) {
                            pcInputString[cInputIndex] = cRxedChar;
                            cInputIndex++;
                        }
                    }
                }
            }
        }
    }
}

void cli_init(void)
{
    printf("Command Line Interface enabled!\n");

    CommandConsoleStart();
    RegisterCLICommands();
}
